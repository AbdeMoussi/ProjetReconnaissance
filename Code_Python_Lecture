import cv2
import pytesseract
pytesseract.pytesseract.tesseract_cmd = r"C:\Program Files\Tesseract-OCR\tesseract.exe"
import numpy as np
import time

# (OPTIONNEL, Windows) indique le chemin si nécessaire :
# pytesseract.pytesseract.tesseract_cmd = r"C:\Program Files\Tesseract-OCR\tesseract.exe"

LANG = "fra+eng"   # langues de l'OCR
OEM  = 3           # 3 = LSTM (par défaut)
PSM  = 6           # 6 = "uniform block of text" (bon pour feuille tenue devant la cam)
CONF_MIN = 60      # seuil de confiance pour afficher (0-100)
OCR_EVERY_N_FRAMES = 6  # lance l'OCR une fois toutes les N frames pour garder du FPS

def preprocess_for_ocr(frame_bgr):
    """Prétraitement doux pour OCR : gris -> filtre -> seuillage adaptatif."""
    gray = cv2.cvtColor(frame_bgr, cv2.COLOR_BGR2GRAY)
    gray = cv2.bilateralFilter(gray, 9, 75, 75)
    th = cv2.adaptiveThreshold(gray, 255,
                               cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                               cv2.THRESH_BINARY, 31, 15)
    return th

def run():
    global PSM
    cap = cv2.VideoCapture(0)
    if not cap.isOpened():
        raise RuntimeError("Impossible d'ouvrir la webcam.")
    # Option : meilleure résolution
    cap.set(cv2.CAP_PROP_FRAME_WIDTH, 1280)
    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 720)

    last_results = []
    i = 0
    prev_t = time.time()

    print("Contrôles: q=quitter | b=bloc (psm 6) | s=scène (psm 11) | l=ligne (psm 7)")

    while True:
        ret, frame = cap.read()
        if not ret:
            break

        display = frame.copy()
        proc = preprocess_for_ocr(frame)

        i += 1
        if i % OCR_EVERY_N_FRAMES == 0:
            config = f"--oem {OEM} --psm {PSM}"
            data = pytesseract.image_to_data(proc, lang=LANG, config=config,
                                             output_type=pytesseract.Output.DICT)
            new_results = []
            n = len(data["text"])
            for k in range(n):
                txt = data["text"][k]
                conf_raw = data["conf"][k]
                try:
                    conf = float(conf_raw)
                except:
                    conf = -1.0
                if txt and txt.strip() and conf >= CONF_MIN:
                    x, y, w, h = data["left"][k], data["top"][k], data["width"][k], data["height"][k]
                    new_results.append((x, y, w, h, txt, conf))
            last_results = new_results

        # Dessin des résultats les plus récents
        for (x, y, w, h, txt, conf) in last_results:
            cv2.rectangle(display, (x, y), (x + w, y + h), (0, 200, 0), 2)
            cv2.putText(display, f"{txt}",
                        (x, max(20, y - 6)), cv2.FONT_HERSHEY_SIMPLEX, 0.7,
                        (0, 0, 255), 2, cv2.LINE_AA)

        # HUD
        now = time.time()
        fps = 1.0 / (now - prev_t) if now > prev_t else 0.0
        prev_t = now
        mode = {6: "bloc", 12: "scene", 7: "ligne"}.get(PSM, str(PSM))
        cv2.putText(display, f"OCR: {LANG} | PSM={PSM} ({mode}) | conf>={CONF_MIN} | {int(fps)} FPS",
                    (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,255), 2, cv2.LINE_AA)
        cv2.putText(display, "b=bloc  s=scene  l=ligne  q=quit",
                    (10, 55), cv2.FONT_HERSHEY_SIMPLEX, 0.55, (255,255,255), 1, cv2.LINE_AA)

        cv2.imshow("Webcam OCR (Tesseract)", display)
        key = cv2.waitKey(1) & 0xFF
        if key == ord('q'):
            break
        elif key == ord('b'):
            PSM = 6   # bloc de texte
        elif key == ord('s'):
            PSM = 12  # texte dispersé (scènes)
        elif key == ord('l'):
            PSM = 7   # une ligne

    cap.release()
    cv2.destroyAllWindows()

if __name__ == "__main__":
    run()
